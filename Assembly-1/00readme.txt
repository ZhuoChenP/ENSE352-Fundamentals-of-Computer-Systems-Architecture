Q1:
the input is r9 and it can take hex and decimal form, but it is binary input. r10 is the store address. 
For the function int_to_ascii. Firstly, to find the sign of the input, if it is negative the function complement will convert it into a positive form with the sign value is r6=0xed, else the sign value is r6=0x20. Next, I divide each byte by 10, to find the correct value in hexadecimal form. Since, the largest number for a byte is oxFF, which means I need to divide it by 3 times to get 255, so, I use 3 registers to store the values. Then, The int value and ASCII value have a difference of #48, so I add #48 for each correct value I obtain. finally, put 00 at the end. to find the end, I shift left 1 byte each time to get the converted value. So, when the input is zero, I know it reaches the end. then, add 00 and store it by to r10 address.
Q2.3
For encrypt, I fetch each element from ram every time. Firstly, find the length of the array and the rotate number n. and check if the rate number is larger than 25, if so, just go through each element and replace it with "X". otherwise, I use four boolean value(registers) to check if the value x>A, x<Z,x>a,x<z. to ensure the char is in the range of a-z or A-Z. if it is not in the range, just move to the next element. However, if it is in the range, which means the total sum of four boolean values is 3. it will add the number n and check if it is overflow, I use two boolean values to check it. one for the overflow y>z, and the other one is y>Z. For checking it, just add the overflow boolean value with the boolean value checking x>Z, if it is two which means the value has overflow from the range A-Z. By using the boolean value, we can also check the other overflow, from the range a-z. if there is overflow, the value will add 6, because there are 6 elements in the ASCII table that do not number, and subtract with 0x20. After all, the difference between the correct value and the recent value is 0x20. and store the correct value into the address contained in r4 and move to the next element. on the other hand, there is not any overflow, just simply store the value in the address of r4 and move the next element.
For decrypt, it is kind of the reverse of encrypting. Most of the parts are the same as it in encrypts, but not the rotate value, number n. The n is the number that rotates from z to a or Z to A which is the opposite direction of encrypting, and the function can hold the overflow, which means rotate 1 value from z to a is rotate 25 values from a to z. So the rotate value is 26-n since there are 26 letters. Therefore we can simply use the encrypted code and just change the rotate value to get the decrypt function.